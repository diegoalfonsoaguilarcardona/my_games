<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Type or Say the Word (with spoken letters on miss)</title>
<style>
  :root {
    --bg: #0f172a;
    --tile: #0f213d;
    --tile-hover: #152a4e;
    --good: #22c55e;
    --bad: #ef4444;
    --text: #e5e7eb;
    --muted: #9ca3af;
    --accent: #60a5fa;
  }
  * { box-sizing: border-box; }
  body {
    margin: 0;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Apple Color Emoji","Segoe UI Emoji";
    background: radial-gradient(1200px 800px at 70% -200px, #12203a 0%, var(--bg) 50%) fixed;
    color: var(--text);
    min-height: 100vh;
    display: grid;
    place-items: center;
  }
  .game {
    width: min(960px, 94vw);
    background: linear-gradient(180deg, rgba(255,255,255,0.04), rgba(255,255,255,0.02));
    border: 1px solid rgba(255,255,255,0.08);
    border-radius: 18px;
    box-shadow: 0 10px 40px rgba(0,0,0,0.35), inset 0 1px 0 rgba(255,255,255,0.06);
    overflow: hidden;
  }
  header {
    padding: 14px 18px;
    background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(0,0,0,0));
    display: grid;
    grid-template-columns: 1fr auto 1fr;
    align-items: center;
    gap: 12px;
  }
  .score, .lives { font-weight: 600; }
  .score span { color: var(--accent); }
  .lives .heart {
    color: #f87171; font-size: 18px; margin: 0 2px;
    filter: drop-shadow(0 0 2px rgba(255,0,0,0.2));
  }
  .timer {
    grid-column: 1 / -1;
    background: rgba(255,255,255,0.08);
    height: 8px; border-radius: 99px; overflow: hidden; position: relative;
  }
  .timer .bar {
    position: absolute; left: 0; top: 0; bottom: 0; width: 100%;
    background: linear-gradient(90deg, #34d399, #60a5fa, #f59e0b);
    transform-origin: left center;
    transition: width 0.1s linear;
  }

  .main { padding: 22px clamp(14px, 3.5vw, 28px) 28px; }
  .prompt {
    display: flex; align-items: center; justify-content: center;
    gap: 12px; margin-bottom: 12px; color: var(--muted); text-align: center;
  }
  .imageWrap {
    display: grid; place-items: center;
    margin: 0 auto 18px;
    width: min(420px, 92%);
    background: radial-gradient(400px 180px at 50% 0%, rgba(255,255,255,0.06), rgba(255,255,255,0.02)) , var(--tile);
    border: 1px solid rgba(255,255,255,0.09);
    border-radius: 16px;
    aspect-ratio: 1 / 1;
    box-shadow: 0 6px 18px rgba(0,0,0,0.25), inset 0 1px 0 rgba(255,255,255,0.05);
  }
  .imageWrap .emoji {
    font-size: clamp(62px, 8.5vw, 120px);
    line-height: 1;
    filter: drop-shadow(0 6px 12px rgba(0,0,0,0.45));
  }
  .imageWrap svg {
    width: 72%;
    height: 72%;
    filter: drop-shadow(0 6px 12px rgba(0,0,0,0.4));
  }

  .typeWrap {
    background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
    border: 1px solid rgba(255,255,255,0.12);
    border-radius: 12px;
    padding: 12px 14px;
    margin: 0 auto;
    width: min(640px, 96%);
    cursor: text;
  }
  .hint { color: var(--muted); font-size: 14px; margin-top: 8px; text-align: center; }
  .letters {
    display: flex; gap: 8px; justify-content: center; align-items: center; flex-wrap: wrap;
    min-height: 48px;
  }
  .slot {
    width: 28px; height: 42px;
    border-bottom: 2px dashed rgba(255,255,255,0.25);
    display: grid; place-items: center;
    font-size: 22px; font-weight: 800; text-transform: lowercase;
  }
  .slot.filled { border-bottom-color: rgba(255,255,255,0.05); }
  .slot.ok { color: var(--good); }
  .slot.bad { color: var(--bad); }
  .caret {
    width: 2px; height: 26px; background: var(--accent);
    margin-left: 2px; animation: blink 1s step-end infinite;
  }
  @keyframes blink { 50% { opacity: 0; } }

  .footer {
    display: flex; justify-content: space-between; align-items: center;
    gap: 12px; padding: 16px 18px 22px; color: var(--muted);
  }
  .btn {
    appearance: none;
    border: 1px solid rgba(255,255,255,0.12);
    background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
    color: var(--text);
    padding: 10px 14px;
    border-radius: 12px;
    font-weight: 600;
    cursor: pointer;
    transition: transform 0.08s ease, background 0.15s ease, border-color 0.15s ease;
  }
  .btn:hover { transform: translateY(-1px); background: rgba(255,255,255,0.08); }
  .btn.primary {
    border-color: rgba(96,165,250,0.6);
    background: linear-gradient(180deg, rgba(96,165,250,0.25), rgba(96,165,250,0.08));
  }
  .btn.mic-on {
    border-color: rgba(34,197,94,0.8);
    background: linear-gradient(180deg, rgba(34,197,94,0.25), rgba(34,197,94,0.08));
  }
  .mic-dot {
    display: inline-block;
    width: 8px; height: 8px; border-radius: 50%;
    margin-left: 6px;
    background: #ef4444;
    box-shadow: 0 0 0 0 rgba(239,68,68,0.7);
    transform: scale(1);
  }
  .mic-on .mic-dot {
    background: #22c55e;
    animation: pulse 1.2s infinite;
  }
  @keyframes pulse {
    0% { box-shadow: 0 0 0 0 rgba(34,197,94, 0.7); }
    70% { box-shadow: 0 0 0 10px rgba(34,197,94, 0); }
    100% { box-shadow: 0 0 0 0 rgba(34,197,94, 0); }
  }

  .overlay {
    position: fixed; inset: 0;
    display: none; place-items: center;
    background: rgba(0,0,0,0.55);
    backdrop-filter: blur(3px);
    z-index: 10;
  }
  .overlay.show { display: grid; }
  .modal {
    width: min(560px, 92vw);
    background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
    border: 1px solid rgba(255,255,255,0.12);
    border-radius: 16px;
    padding: 20px;
    text-align: center;
    box-shadow: 0 18px 60px rgba(0,0,0,0.45);
  }
  .modal h2 { margin: 0 0 10px; font-size: 28px; }
  .modal p { color: var(--muted); margin: 0 0 14px; }

  #trap { position: absolute; left: -9999px; top: -9999px; width: 0; height: 0; opacity: 0; }
</style>
</head>
<body>
  <div class="game" role="application" aria-label="Type or say the word">
    <header>
      <div class="score" aria-live="polite">Score: <span id="score">0</span></div>
      <div style="text-align:center; font-weight:700; letter-spacing:0.4px;">Look at the picture and spell the word</div>
      <div class="lives" aria-live="polite" aria-label="Lives">
        <span class="heart" id="heart1">‚ù§</span>
        <span class="heart" id="heart2">‚ù§</span>
        <span class="heart" id="heart3">‚ù§</span>
      </div>
      <div class="timer" aria-hidden="true"><div class="bar" id="timebar" style="width:100%"></div></div>
    </header>

    <div class="main">
      <div class="prompt">Type on the keyboard or use the mic and say each letter.</div>

      <div class="imageWrap" id="image" aria-label="Picture to identify"></div>

      <div class="typeWrap" id="typeWrap" tabindex="0" role="group" aria-label="Typing area">
        <div class="letters" id="letters"></div>
      </div>
      <div class="hint">Keyboard: type letters, Backspace deletes, Enter submits. Mic: tap ‚ÄúStart voice‚Äù and say the next letter.</div>
      <input id="trap" type="text" autocomplete="off" />
    </div>

    <div class="footer">
      <div id="status" aria-live="polite"></div>
      <div>
        <button id="micBtn" class="btn" title="Toggle voice spelling">üé§ Start voice <span class="mic-dot" aria-hidden="true"></span></button>
        <button id="restart" class="btn">Restart</button>
        <button id="skip" class="btn primary" title="Skip (lose a life)">Skip</button>
      </div>
    </div>
  </div>

  <div class="overlay" id="gameover">
    <div class="modal">
      <h2>Game Over</h2>
      <p>Your score: <strong id="finalScore">0</strong></p>
      <button id="playAgain" class="btn primary">Play again</button>
    </div>
  </div>

<script>
  // Words to learn (15 items)
  const WORDS = [
    "burrow","liter","lungs","sentence","den","street","strong","gills",
    "hard","dinner","oxygen","tshirt","tick","cross","hive"
  ];

  // Emoji/SVG/icon for each word
  function iconHTMLFor(word) {
    const span = (e) => `<span class="emoji" aria-hidden="true">${e}</span>`;
    switch (word) {
      case "burrow":   return span("üï≥Ô∏è");
      case "liter":    return svgBottle1L();
      case "lungs":    return span("ü´Å");
      case "sentence": return span("üìù");
      case "den":      return svgCave();
      case "street":   return span("üõ£Ô∏è");
      case "strong":   return span("üí™");
      case "gills":    return span("üêü");
      case "hard":     return span("ü™®");
      case "dinner":   return span("üçΩÔ∏è");
      case "oxygen":   return svgO2();
      case "tshirt":   return span("üëï");
      case "tick":     return span("‚úÖ");
      case "cross":    return span("‚ùå");
      case "hive":     return span("üçØüêù");
      default:         return span("‚ùì");
    }
  }

  // SVGs
  function svgCave() {
    return `
      <svg viewBox="0 0 100 100" role="img" aria-label="Cave / Den">
        <defs>
          <linearGradient id="caveGrad" x1="0" y1="0" x2="0" y2="1">
            <stop offset="0%" stop-color="#5b6470"/>
            <stop offset="100%" stop-color="#2a2f38"/>
          </linearGradient>
        </defs>
        <path d="M10 90 Q50 10 90 90 Z" fill="url(#caveGrad)" stroke="#1f242c" stroke-width="2"/>
        <path d="M32 90 Q50 45 68 90 Z" fill="#171a1f"/>
      </svg>`;
  }

  function svgBottle1L() {
    return `
      <svg viewBox="0 0 100 100" role="img" aria-label="Bottle labeled 1 liter">
        <defs>
          <linearGradient id="glass" x1="0" y1="0" x2="0" y2="1">
            <stop offset="0%" stop-color="#dbeafe"/>
            <stop offset="100%" stop-color="#93c5fd"/>
          </linearGradient>
        </defs>
        <rect x="38" y="10" width="24" height="10" rx="3" fill="#1e40af"/>
        <path d="M35 20 Q50 20 65 20 L65 78 Q65 90 50 90 Q35 90 35 78 Z"
              fill="url(#glass)" stroke="#1e3a8a" stroke-width="2"/>
        <text x="50" y="62" text-anchor="middle" font-size="24" font-weight="900" fill="#0b1531">1L</text>
      </svg>`;
  }

  function svgO2() {
    return `
      <svg viewBox="0 0 100 100" role="img" aria-label="Oxygen O2 bubble">
        <defs>
          <radialGradient id="bubble" cx="35%" cy="30%" r="70%">
            <stop offset="0%" stop-color="#e0f2fe"/>
            <stop offset="100%" stop-color="#60a5fa"/>
          </radialGradient>
        </defs>
        <circle cx="50" cy="50" r="40" fill="url(#bubble)" stroke="#1d4ed8" stroke-width="2" />
        <text x="50" y="58" text-anchor="middle" font-size="30" font-weight="900" fill="#0b1531">
          O<tspan dy="6" font-size="18">2</tspan>
        </text>
      </svg>`;
  }

  // Utility: shuffle array in-place
  function shuffle(arr) {
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  }

  // Small async helpers
  function wait(ms) {
    return new Promise(res => setTimeout(res, ms));
  }

  // Speech synthesis (Web Speech API)
  const TTS = {
    supported: 'speechSynthesis' in window && 'SpeechSynthesisUtterance' in window,
    voice: null,
    ready: false
  };

  function speak(text, opts = {}) {
    return new Promise((resolve, reject) => {
      if (!TTS.supported) return resolve();
      const u = new SpeechSynthesisUtterance(String(text));
      u.lang = (TTS.voice && TTS.voice.lang) ? TTS.voice.lang : 'en-US';
      u.voice = TTS.voice || null;
      u.rate = opts.rate ?? 1.0;
      u.pitch = opts.pitch ?? 1.0;
      u.volume = opts.volume ?? 1.0;
      u.onend = resolve;
      u.onerror = resolve; // resolve on error to avoid getting stuck
      speechSynthesis.speak(u);
    });
  }

  function primeTTS() {
    if (!TTS.supported) return;
    try {
      const u = new SpeechSynthesisUtterance(' ');
      u.lang = (TTS.voice && TTS.voice.lang) ? TTS.voice.lang : 'en-US';
      u.voice = TTS.voice || null;
      u.rate = 1.0;
      u.pitch = 1.0;
      u.volume = 0.01; // near-silent warm-up to avoid first-utterance fade-in
      u.onend = null;
      u.onerror = null;
      speechSynthesis.speak(u);
    } catch {}
  }

  async function speakLettersThenWord(word) {
    if (!TTS.supported) {
      await wait(1200);
      return;
    }
    try { speechSynthesis.cancel(); } catch {}
    for (const ch of word.toLowerCase()) {
      await speak(ch, { rate: 1.0 });
    }
    await wait(1000);
    await speak(word.toLowerCase(), { rate: 0.95 });
  }

  function pickVoice() {
    if (!TTS.supported) return;
    const voices = speechSynthesis.getVoices();
    TTS.voice = voices.find(v => /^en(-|_|$)/i.test(v.lang)) || voices[0] || null;
    TTS.ready = true;
  }

  if (TTS.supported) {
    pickVoice();
    window.speechSynthesis.addEventListener('voiceschanged', pickVoice);
  }

  // Speech Recognition (Web Speech API) - Voice spelling
  const SR = {
    supported: !!(window.SpeechRecognition || window.webkitSpeechRecognition),
    rec: null,
    listening: false,
    auto: false,           // keep listening across rounds
    suspended: false       // temporarily paused by app while TTS is speaking
  };

  const micBtn = document.getElementById('micBtn');

  if (!SR.supported) {
    micBtn.disabled = true;
    micBtn.title = 'Voice recognition not supported on this browser';
    micBtn.textContent = 'üé§ Voice not available';
  } else {
    const Ctor = window.SpeechRecognition || window.webkitSpeechRecognition;
    SR.rec = new Ctor();
    SR.rec.lang = 'en-US';
    SR.rec.continuous = true;
    SR.rec.interimResults = false;
    SR.rec.maxAlternatives = 3;
  }

  function updateMicUI() {
    if (!micBtn) return;
    if (SR.listening) {
      micBtn.classList.add('mic-on');
      micBtn.innerHTML = 'üé§ Listening‚Ä¶ <span class="mic-dot" aria-hidden="true"></span>';
    } else {
      micBtn.classList.remove('mic-on');
      micBtn.innerHTML = 'üé§ Start voice <span class="mic-dot" aria-hidden="true"></span>';
    }
  }

  function startListening() {
    if (!SR.supported || !SR.rec) return;
    try {
      try { speechSynthesis.cancel(); } catch {}
      SR.rec.start();
    } catch (e) {
      // start can throw if already started; ignore
    }
  }

  function stopListening() {
    if (!SR.supported || !SR.rec) return;
    try { SR.rec.stop(); } catch {}
  }

  async function withRecognitionSuspended(task) {
    const shouldResume = SR.supported && SR.auto && SR.listening;
    if (SR.supported && SR.listening) {
      SR.suspended = true;
      stopListening();
    }
    try {
      await task();
    } finally {
      SR.suspended = false;
      if (shouldResume) {
        // Small delay to allow mic to settle
        await wait(150);
        startListening();
      }
    }
  }

  // Letter-name mapping (common variants)
  const LETTER_ALIASES = {
    a: ["a","ay","eh","ey"],
    b: ["b","be","bee"],
    c: ["c","see","sea","cee"],
    d: ["d","dee"],
    e: ["e","ee"],
    f: ["f","ef","eff"],
    g: ["g","gee"],
    h: ["h","aitch","h"],
    i: ["i","eye","aye"],
    j: ["j","jay"],
    k: ["k","kay"],
    l: ["l","el","ell"],
    m: ["m","em"],
    n: ["n","en"],
    o: ["o","oh"],
    p: ["p","pee","pea"],
    q: ["q","cue","queue"],
    r: ["r","are","ar"],
    s: ["s","ess"],
    t: ["t","tee","tea"],
    u: ["u","you","yew"],
    v: ["v","vee"],
    w: ["w","double u","double you","w"],
    x: ["x","ex"],
    y: ["y","why"],
    z: ["z","zee","zed"]
  };
  const ALIAS_TO_LETTER = new Map();
  for (const [letter, aliases] of Object.entries(LETTER_ALIASES)) {
    ALIAS_TO_LETTER.set(letter, letter);
    for (const a of aliases) ALIAS_TO_LETTER.set(a, letter);
  }

  function mapAlias(token) {
    if (!token) return null;
    const t = token.toLowerCase().trim();
    if (t.length === 1 && /^[a-z]$/.test(t)) return t;
    return ALIAS_TO_LETTER.get(t) || null;
  }

  function transcriptToLetters(text) {
    if (!text) return [];
    let t = String(text).toLowerCase();
    t = t.replace(/[-_]/g, ' ');
    t = t.replace(/[^a-z\s]/g, ' ');
    t = t.replace(/\s+/g, ' ').trim();

    const words = t.split(' ').filter(Boolean);
    const out = [];
    for (let i = 0; i < words.length; i++) {
      const w = words[i];

      if (w === 'letter' && words[i+1]) {
        const mapped = mapAlias(words[++i]);
        if (mapped) out.push(mapped);
        continue;
      }
      if (w === 'double' && words[i+1]) {
        // handle "double you" or "double u" or "double l"
        const two = (words[i+1] ? (words[i+1] + (words[i+2] ? ' ' + words[i+2] : '')) : '');
        let mapped = mapAlias(two);
        if (mapped) {
          out.push(mapped, mapped);
          i += 2;
          continue;
        }
        const single = mapAlias(words[++i]);
        if (single) {
          out.push(single, single);
        }
        continue;
      }
      // try two-word alias like "double you" already above, but keep generic two-word mapping if any
      if (words[i+1]) {
        const two = w + ' ' + words[i+1];
        const mapped2 = mapAlias(two);
        if (mapped2) {
          out.push(mapped2);
          i += 1;
          continue;
        }
      }
      const one = mapAlias(w);
      if (one) out.push(one);
    }
    return out;
  }

  // DOM
  const imageEl = document.getElementById('image');
  const lettersEl = document.getElementById('letters');
  const typeWrapEl = document.getElementById('typeWrap');
  const scoreEl = document.getElementById('score');
  const statusEl = document.getElementById('status');
  const timebarEl = document.getElementById('timebar');
  const overlayEl = document.getElementById('gameover');
  const finalScoreEl = document.getElementById('finalScore');
  const restartBtn = document.getElementById('restart');
  const skipBtn = document.getElementById('skip');
  const playAgainBtn = document.getElementById('playAgain');
  const trapInput = document.getElementById('trap');

  // State
  let score = 0;
  let lives = 3;
  let queue = [];
  let currentWord = null;
  let answered = false;
  let timerId = null;

  const BASE_MS = 30000;     // 30 seconds
  const DECREMENT_MS = 500;  // -0.5s each new word
  const MIN_MS = 8000;       // floor so it doesn't get too tiny
  let roundsPlayed = 0;

  let typed = '';

  function speakLetter(ch) {
    if (!TTS.supported) return;
    // Avoid TTS while mic is listening to prevent self-capture
    if (SR.supported && SR.listening) return;
    try { speechSynthesis.cancel(); } catch {}
    // Lowercase to avoid "Capital H"
    speak(ch.toLowerCase());
  }

  function updateScore() { scoreEl.textContent = score; }
  function updateLives() {
    for (let i = 1; i <= 3; i++) {
      const el = document.getElementById('heart' + i);
      el.style.visibility = (i <= lives) ? 'visible' : 'hidden';
    }
  }

  function focusTrap() {
    trapInput.value = '';
    trapInput.focus({ preventScroll: true });
  }

  function resetGame() {
    score = 0;
    lives = 3;
    roundsPlayed = 0;
    queue = shuffle([...WORDS]);
    updateScore();
    updateLives();
    statusEl.textContent = TTS.supported ? '' : 'Tip: Your browser does not support speech. Use Chrome, Edge, or Safari.';
    overlayEl.classList.remove('show');
    nextRound();
  }

  function gameOver() {
    stopTimer();
    finalScoreEl.textContent = score;
    overlayEl.classList.add('show');
    // Stop mic when game is over
    SR.auto = false;
    stopListening();
  }

  function getRoundDuration() {
    const ms = BASE_MS - roundsPlayed * DECREMENT_MS;
    return Math.max(MIN_MS, ms);
  }

  function nextRound() {
    stopTimer();
    answered = false;
    typed = '';
    timebarEl.style.width = '100%';
    statusEl.textContent = SR.supported ? 'Say the next letter or type it.' : (TTS.supported ? '' : 'Tip: Enable speech features for best experience.');

    if (queue.length === 0) queue = shuffle([...WORDS]);
    currentWord = queue.pop();
    imageEl.innerHTML = iconHTMLFor(currentWord);
    primeTTS(); // warm up TTS so first key press isn't clipped

    renderTyped();
    startTimer(getRoundDuration());
    setTimeout(focusTrap, 0);

    // If voice was toggled on, keep listening into the next round
    if (SR.supported && SR.auto && !SR.listening) startListening();
  }

  function renderTyped() {
    const target = currentWord.toLowerCase();
    lettersEl.innerHTML = '';
    const maxSlots = target.length;

    for (let i = 0; i < maxSlots; i++) {
      const span = document.createElement('span');
      span.className = 'slot';
      const ch = typed[i];
      if (ch) {
        span.classList.add('filled');
        const ok = ch.toLowerCase() === target[i];
        span.classList.add(ok ? 'ok' : 'bad');
        span.textContent = ch.toLowerCase();
      } else {
        span.textContent = '';
      }
      lettersEl.appendChild(span);
    }
    if (!answered && typed.length < maxSlots) {
      const caret = document.createElement('div');
      caret.className = 'caret';
      lettersEl.appendChild(caret);
    }
  }

  async function handleMiss(prefixMsg) {
    // Show the correct word in the slots
    typed = currentWord;
    renderTyped();

    // Status message
    statusEl.textContent = `${prefixMsg} It was ‚Äú${currentWord}‚Äù.`;

    // Speak letters then the word, with a 1s pause in between (pause mic during TTS)
    await withRecognitionSuspended(() => speakLettersThenWord(currentWord));

    // Move on
    if (lives <= 0) gameOver();
    else {
      roundsPlayed += 1;
      nextRound();
    }
  }

  async function submitTyped() {
    if (answered) return;
    if (typed.length === 0) {
      statusEl.textContent = "Type or say the word first";
      return;
    }
    answered = true;
    stopTimer();

    const isCorrect = typed.toLowerCase() === currentWord.toLowerCase();
    if (isCorrect) {
      score += 1;
      statusEl.textContent = 'Great!';
      updateScore();
      renderTyped();
      try { speechSynthesis.cancel(); } catch {}
      await withRecognitionSuspended(() => speak(currentWord.toLowerCase(), { rate: 0.95 }));
      await wait(600);
      if (lives <= 0) gameOver();
      else {
        roundsPlayed += 1;
        nextRound();
      }
    } else {
      lives -= 1;
      updateLives();
      updateScore();
      await handleMiss('Oops!');
    }
  }

  function startTimer(ms) {
    const start = performance.now();
    timebarEl.style.transition = 'none';
    timebarEl.style.width = '100%';
    requestAnimationFrame(() => { timebarEl.style.transition = 'width 0.1s linear'; });

    timerId = setInterval(() => {
      const elapsed = performance.now() - start;
      const remain = Math.max(0, ms - elapsed);
      const pct = (remain / ms) * 100;
      timebarEl.style.width = pct + '%';
      if (remain <= 0) {
        onTimeUp();
      }
    }, 100);
  }

  function stopTimer() {
    if (timerId) {
      clearInterval(timerId);
      timerId = null;
    }
  }

  async function onTimeUp() {
    if (answered) return;
    answered = true;
    stopTimer();
    lives -= 1;
    updateLives();
    await handleMiss('Time‚Äôs up!');
  }

  // Voice processing: accept letters from SR and verify against expected
  function acceptLettersFromVoice(letters) {
    const target = currentWord.toLowerCase();
    for (const l of letters) {
      if (answered) return;
      const idx = typed.length;
      if (idx >= target.length) return;
      const expected = target[idx];
      if (l === expected) {
        typed += l;
        renderTyped();
        statusEl.textContent = `Good: ${l.toUpperCase()}`;
        if (typed.length === target.length) {
          submitTyped(); // auto-submit when filled
          return;
        }
      } else {
        statusEl.textContent = `I heard "${l.toUpperCase()}". We need "${expected.toUpperCase()}". Try again.`;
        // Do not penalize; wait for another attempt
        return;
      }
    }
  }

  // SR event handlers
  if (SR.supported && SR.rec) {
    SR.rec.onstart = () => {
      SR.listening = true;
      updateMicUI();
      statusEl.textContent = 'Listening... say the next letter.';
    };
    SR.rec.onend = () => {
      SR.listening = false;
      updateMicUI();
      // Auto-restart if user wants continuous listening and not suspended by TTS
      if (SR.auto && !SR.suspended && !overlayEl.classList.contains('show') && !answered) {
        setTimeout(() => startListening(), 150);
      }
    };
    SR.rec.onerror = (e) => {
      // Common errors: 'no-speech', 'audio-capture', 'not-allowed'
      if (e && e.error === 'not-allowed') {
        SR.auto = false;
        micBtn && (micBtn.disabled = true);
        statusEl.textContent = 'Mic permission denied. You can keep using the keyboard.';
      } else {
        statusEl.textContent = 'Didn‚Äôt catch that. Try again or use the keyboard.';
      }
    };
    SR.rec.onresult = (event) => {
      for (let i = event.resultIndex; i < event.results.length; i++) {
        const res = event.results[i];
        if (!res.isFinal) continue;
        const alt = res[0];
        const transcript = (alt && alt.transcript) ? alt.transcript : '';
        const letters = transcriptToLetters(transcript);
        if (!letters.length) {
          statusEl.textContent = `I heard: "${transcript.trim()}". Say a single letter (like "B").`;
          continue;
        }
        acceptLettersFromVoice(letters);
      }
    };
  }

  // Keyboard handling (single listener to avoid duplicates)
  function handleKeydown(e) {
    if (overlayEl.classList.contains('show')) return;
    if (answered) return;

    const key = e.key;

    if (key === 'Enter') {
      e.preventDefault();
      submitTyped();
      return;
    }
    if (key === 'Backspace') {
      e.preventDefault();
      if (typed.length > 0) {
        typed = typed.slice(0, -1);
        renderTyped();
      }
      return;
    }

    // Accept a-z letters only
    if (/^[a-z]$/i.test(key)) {
      e.preventDefault(); // prevent the hidden input from capturing the character
      const limit = currentWord.length;
      if (typed.length < limit) {
        const letter = key.toLowerCase();
        const target = currentWord.toLowerCase();
        const expected = target[typed.length];
        if (letter === expected) {
          typed += letter;
          renderTyped();
          speakLetter(letter);
          if (typed.length === limit) submitTyped();
        } else {
          statusEl.textContent = `You typed "${letter.toUpperCase()}". We need "${expected.toUpperCase()}".`;
        }
      }
      return;
    }
  }

  // Buttons
  restartBtn.addEventListener('click', resetGame);
  skipBtn.addEventListener('click', () => {
    if (answered) return;
    onTimeUp(); // skipping costs a life and moves on with the same miss flow
  });
  playAgainBtn.addEventListener('click', resetGame);
  typeWrapEl.addEventListener('click', focusTrap);

  micBtn.addEventListener('click', () => {
    if (!SR.supported) return;
    // Toggle continuous listening
    SR.auto = !SR.auto;
    if (SR.auto) {
      startListening();
    } else {
      stopListening();
      statusEl.textContent = 'Voice off. You can still type.';
    }
    updateMicUI();
  });

  window.addEventListener('keydown', handleKeydown);

  // Start
  resetGame();
</script>
</body>
</html>